"use client"

import { useState, useEffect, useRef } from 'react'
import { Play, Pause, RotateCcw, Clock, CheckCircle, PauseCircle } from 'lucide-react'
import { useAuth } from '../../../contexts/AuthContext'

interface TimerEntry {
  _id: string
  startTime: string
  endTime?: string
  duration: number
  status: 'running' | 'stopped'
}

export default function TimerPage() {
  const { user } = useAuth()
  const [isRunning, setIsRunning] = useState(false)
  const [time, setTime] = useState(0)
  const [currentTimer, setCurrentTimer] = useState<TimerEntry | null>(null)
  const [todayTotal, setTodayTotal] = useState(0)
  const [todayEntries, setTodayEntries] = useState<TimerEntry[]>([])
  const [loading, setLoading] = useState(false)
  const [error, setError] = useState<string | null>(null)
  const intervalRef = useRef<NodeJS.Timeout | null>(null)

  // Format time to HH:MM:SS
  const formatTime = (seconds: number) => {
    const hrs = Math.floor(seconds / 3600)
    const mins = Math.floor((seconds % 3600) / 60)
    const secs = seconds % 60
    return `${hrs.toString().padStart(2, '0')}:${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`
  }

  // Format to hours with decimals
  const formatHours = (seconds: number) => {
    return (seconds / 3600).toFixed(2)
  }

  // Load timer data
  const loadTimerData = async () => {
    if (!user) return
    
    try {
      setLoading(true)
      const response = await fetch(`/api/timer?userId=${user.id || 'demo'}`)
      const data = await response.json()
      
      if (data.success) {
        setCurrentTimer(data.currentEntry)
        setTodayEntries(data.todayEntries || [])
        setTodayTotal(data.totalToday || 0)
        
        // If timer is running, calculate elapsed time
        if (data.currentEntry) {
          setIsRunning(true)
          const startTime = new Date(data.currentEntry.startTime).getTime()
          const now = Date.now()
          const elapsed = Math.floor((now - startTime) / 1000)
          setTime(elapsed)
          
          // Start timer updates
          if (intervalRef.current) clearInterval(intervalRef.current)
          intervalRef.current = setInterval(() => {
            setTime(prev => prev + 1)
          }, 1000)
        } else {
          setIsRunning(false)
          setTime(0)
          if (intervalRef.current) {
            clearInterval(intervalRef.current)
            intervalRef.current = null
          }
        }
      }
    } catch (err) {
      console.error('Error loading timer:', err)
      setError('Fehler beim Laden des Timers')
    } finally {
      setLoading(false)
    }
  }

  useEffect(() => {
    if (user) {
      loadTimerData()
    }
    
    return () => {
      if (intervalRef.current) {
        clearInterval(intervalRef.current)
      }
    }
  }, [user])

  const handleStartTimer = async () => {
    if (!user) {
      setError('Bitte einloggen')
      return
    }
    
    try {
      setLoading(true)
      const response = await fetch('/api/timer', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          userId: user.id || 'demo',
          action: 'start'
        })
      })
      
      const data = await response.json()
      
      if (data.success) {
        setIsRunning(true)
        setCurrentTimer(data.entry)
        setTime(0)
        
        // Start timer updates
        if (intervalRef.current) clearInterval(intervalRef.current)
        intervalRef.current = setInterval(() => {
          setTime(prev => prev + 1)
        }, 1000)
        
        // Reload data
        await loadTimerData()
      } else {
        setError(data.message || 'Fehler beim Starten')
      }
    } catch (err) {
      console.error('Error starting timer:', err)
      setError('Fehler beim Starten des Timers')
    } finally {
      setLoading(false)
    }
  }

  const handleStopTimer = async () => {
    if (!currentTimer?._id) return
    
    try {
      setLoading(true)
      const response = await fetch('/api/timer', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          userId: user?.id || 'demo',
          action: 'stop',
          entryId: currentTimer._id
        })
      })
      
      const data = await response.json()
      
      if (data.success) {
        setIsRunning(false)
        setCurrentTimer(null)
        setTime(0)
        
        if (intervalRef.current) {
          clearInterval(intervalRef.current)
          intervalRef.current = null
        }
        
        // Reload data
        await loadTimerData()
      } else {
        setError(data.message || 'Fehler beim Stoppen')
      }
    } catch (err) {
      console.error('Error stopping timer:', err)
      setError('Fehler beim Stoppen des Timers')
    } finally {
      setLoading(false)
    }
  }

  const handleReset = () => {
    setTime(0)
    if (!isRunning) {
      setCurrentTimer(null)
    }
  }

  // Inline Styles for clean design
  const styles = {
    container: {
      minHeight: '100vh',
      background: 'linear-gradient(135deg, #0f172a 0%, #1e293b 100%)',
      color: 'white',
      padding: '1rem'
    },
    
    header: {
      textAlign: 'center' as const,
      marginBottom: '2rem'
    },
    
    title: {
      fontSize: '2.5rem',
      fontWeight: 'bold',
      marginBottom: '0.5rem',
      background: 'linear-gradient(90deg, #60a5fa 0%, #a78bfa 100%)',
      WebkitBackgroundClip: 'text',
      WebkitTextFillColor: 'transparent'
    },
    
    subtitle: {
      color: '#94a3b8',
      fontSize: '1rem'
    },
    
    timerCard: {
      background: 'rgba(30, 41, 59, 0.7)',
      backdropFilter: 'blur(10px)',
      borderRadius: '2rem',
      padding: '3rem 2rem',
      maxWidth: '600px',
      margin: '0 auto 2rem auto',
      border: '1px solid rgba(255, 255, 255, 0.1)',
      boxShadow: '0 20px 40px rgba(0, 0, 0, 0.3)'
    },
    
    timeDisplay: {
      fontSize: '5rem',
      fontWeight: 'bold',
      textAlign: 'center' as const,
      fontFamily: "'Roboto Mono', monospace",
      marginBottom: '2rem',
      textShadow: '0 0 20px rgba(96, 165, 250, 0.5)'
    },
    
    buttonGroup: {
      display: 'flex',
      justifyContent: 'center',
      gap: '1rem',
      marginBottom: '2rem'
    },
    
    button: {
      padding: '1rem 2rem',
      borderRadius: '9999px',
      border: 'none',
      fontSize: '1.1rem',
      fontWeight: '600',
      cursor: 'pointer',
      display: 'flex',
      alignItems: 'center',
      gap: '0.5rem',
      transition: 'all 0.2s'
    },
    
    startButton: {
      background: 'linear-gradient(90deg, #10b981 0%, #059669 100%)',
      color: 'white'
    },
    
    stopButton: {
      background: 'linear-gradient(90deg, #ef4444 0%, #dc2626 100%)',
      color: 'white'
    },
    
    resetButton: {
      background: 'rgba(255, 255, 255, 0.1)',
      color: 'white',
      border: '1px solid rgba(255, 255, 255, 0.2)'
    },
    
    statsCard: {
      background: 'rgba(30, 41, 59, 0.7)',
      backdropFilter: 'blur(10px)',
      borderRadius: '1.5rem',
      padding: '2rem',
      marginBottom: '1.5rem',
      border: '1px solid rgba(255, 255, 255, 0.1)'
    },
    
    statsTitle: {
      fontSize: '1.25rem',
      fontWeight: '600',
      marginBottom: '1rem',
      display: 'flex',
      alignItems: 'center',
      gap: '0.5rem'
    },
    
    statsGrid: {
      display: 'grid',
      gridTemplateColumns: 'repeat(auto-fit, minmax(200px, 1fr))',
      gap: '1rem'
    },
    
    statItem: {
      textAlign: 'center' as const,
      padding: '1rem',
      background: 'rgba(255, 255, 255, 0.05)',
      borderRadius: '1rem'
    },
    
    statValue: {
      fontSize: '1.5rem',
      fontWeight: 'bold',
      marginBottom: '0.25rem'
    },
    
    statLabel: {
      color: '#94a3b8',
      fontSize: '0.875rem'
    },
    
    entriesList: {
      marginTop: '1rem'
    },
    
    entryItem: {
      display: 'flex',
      justifyContent: 'space-between',
      alignItems: 'center',
      padding: '1rem',
      background: 'rgba(255, 255, 255, 0.05)',
      borderRadius: '0.75rem',
      marginBottom: '0.5rem'
    },
    
    entryTime: {
      fontFamily: "'Roboto Mono', monospace",
      fontWeight: '600'
    },
    
    entryDuration: {
      color: '#60a5fa'
    },
    
    loading: {
      textAlign: 'center' as const,
      padding: '2rem',
      color: '#94a3b8'
    },
    
    error: {
      background: 'rgba(239, 68, 68, 0.1)',
      border: '1px solid rgba(239, 68, 68, 0.3)',
      color: '#fecaca',
      padding: '1rem',
      borderRadius: '0.75rem',
      marginBottom: '1rem'
    }
  }

  if (loading && !currentTimer) {
    return (
      <div style={styles.container}>
        <div style={styles.loading}>
          <div style={{
            width: '3rem',
            height: '3rem',
            border: '3px solid rgba(96, 165, 250, 0.3)',
            borderTop: '3px solid #60a5fa',
            borderRadius: '50%',
            animation: 'spin 1s linear infinite',
            margin: '0 auto 1rem auto'
          }}></div>
          <p>Lade Timer...</p>
        </div>
      </div>
    )
  }

  return (
    <div style={styles.container}>
      <style>{`
        @keyframes spin {
          to { transform: rotate(360deg); }
        }
        @keyframes pulse {
          0%, 100% { opacity: 1; }
          50% { opacity: 0.7; }
        }
      `}</style>
      
      {/* Header */}
      <div style={styles.header}>
        <h1 style={styles.title}>Work Timer</h1>
        <p style={styles.subtitle}>Track your working hours</p>
      </div>

      {/* Error Message */}
      {error && (
        <div style={styles.error}>
           {error}
          <button 
            onClick={() => setError(null)}
            style={{
              background: 'none',
              border: 'none',
              color: '#fca5a5',
              marginLeft: '1rem',
              cursor: 'pointer'
            }}
          >
            
          </button>
        </div>
      )}

      {/* Main Timer Card */}
      <div style={styles.timerCard}>
        <div style={styles.timeDisplay}>
          {formatTime(time)}
        </div>
        
        <div style={styles.buttonGroup}>
          {!isRunning ? (
            <button
              onClick={handleStartTimer}
              disabled={loading}
              style={{
                ...styles.button,
                ...styles.startButton,
                opacity: loading ? 0.6 : 1
              }}
              onMouseEnter={e => e.currentTarget.style.transform = 'scale(1.05)'}
              onMouseLeave={e => e.currentTarget.style.transform = 'scale(1)'}
            >
              <Play size={20} />
              Start Work
            </button>
          ) : (
            <button
              onClick={handleStopTimer}
              disabled={loading}
              style={{
                ...styles.button,
                ...styles.stopButton,
                opacity: loading ? 0.6 : 1,
                animation: 'pulse 2s infinite'
              }}
              onMouseEnter={e => e.currentTarget.style.transform = 'scale(1.05)'}
              onMouseLeave={e => e.currentTarget.style.transform = 'scale(1)'}
            >
              <Pause size={20} />
              Stop Work
            </button>
          )}
          
          <button
            onClick={handleReset}
            disabled={isRunning || loading}
            style={{
              ...styles.button,
              ...styles.resetButton,
              opacity: (isRunning || loading) ? 0.5 : 1,
              cursor: (isRunning || loading) ? 'not-allowed' : 'pointer'
            }}
            onMouseEnter={e => !isRunning && !loading && (e.currentTarget.style.transform = 'scale(1.05)')}
            onMouseLeave={e => e.currentTarget.style.transform = 'scale(1)'}
          >
            <RotateCcw size={20} />
            Reset
          </button>
        </div>
        
        {/* Status */}
        <div style={{
          textAlign: 'center',
          color: isRunning ? '#10b981' : '#94a3b8',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
          gap: '0.5rem',
          fontSize: '1.1rem'
        }}>
          {isRunning ? (
            <>
              <div style={{
                width: '8px',
                height: '8px',
                borderRadius: '50%',
                background: '#10b981',
                animation: 'pulse 2s infinite'
              }} />
              Timer läuft...
            </>
          ) : (
            <>
              <PauseCircle size={20} />
              Timer gestoppt
            </>
          )}
        </div>
      </div>

      {/* Stats Card */}
      <div style={styles.statsCard}>
        <h2 style={styles.statsTitle}>
          <Clock size={20} />
          Today's Summary
        </h2>
        
        <div style={styles.statsGrid}>
          <div style={styles.statItem}>
            <div style={styles.statValue}>{formatHours(todayTotal)}h</div>
            <div style={styles.statLabel}>Total Hours</div>
          </div>
          
          <div style={styles.statItem}>
            <div style={styles.statValue}>{todayEntries.length}</div>
            <div style={styles.statLabel}>Sessions</div>
          </div>
          
          <div style={styles.statItem}>
            <div style={styles.statValue}>{isRunning ? 'Active' : 'Inactive'}</div>
            <div style={styles.statLabel}>Current Status</div>
          </div>
          
          <div style={styles.statItem}>
            <div style={styles.statValue}>
              {todayEntries.length > 0 ? formatHours(todayEntries[todayEntries.length - 1]?.duration || 0) + 'h' : '0h'}
            </div>
            <div style={styles.statLabel}>Last Session</div>
          </div>
        </div>
      </div>

      {/* Today's Entries */}
      {todayEntries.length > 0 && (
        <div style={styles.statsCard}>
          <h2 style={styles.statsTitle}>
            <CheckCircle size={20} />
            Today's Sessions
          </h2>
          
          <div style={styles.entriesList}>
            {todayEntries.slice().reverse().map((entry, index) => (
              <div key={entry._id} style={styles.entryItem}>
                <div>
                  <div style={{ fontSize: '0.875rem', color: '#94a3b8' }}>
                    Session {todayEntries.length - index}
                  </div>
                  <div style={styles.entryTime}>
                    {new Date(entry.startTime).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}
                  </div>
                </div>
                <div style={styles.entryDuration}>
                  {formatTime(entry.duration)}
                </div>
              </div>
            ))}
          </div>
        </div>
      )}

      {/* User Info */}
      {user && (
        <div style={{
          textAlign: 'center',
          color: '#94a3b8',
          fontSize: '0.875rem',
          marginTop: '2rem'
        }}>
          Angemeldet als: {user.name}  Timer wird gespeichert
        </div>
      )}
    </div>
  )
}
